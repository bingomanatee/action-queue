# Wonderland Labs' Action Queue

This is a process throttler for multiple actions. When you want
to do multiple things but limit concurrent activity, you can use
this class to manage pending actions. 

The functions are expected to be asynchronous; they are executed
inside "await" and marked as complete after the promise is resolved.
(Sync functions should satisfy this behavior but are discouraged).

ActionQueue uses rxjs subjects as queues to hold delayed functions
until the number of currently processing functions is under or equal to
the created limit:

```javascript

import ActionQueue from '@wonderlandlabs/action=-queue';

let queue = new ActionQueue(3);

action.process(myLongFunction1).then(() => console.log('function 1 is done'));
action.add(myLongFunction2).then(() => console.log('function 2 is done'));
action.add(myLongFunction3).then(() => console.log('function 3 is done'));

```

3 in this case is the `maxConcurrency` -- the maximum number of tasks
that will be attempted concurrently. Once more tasks are added, they 
will be suspended until 

## thrown errors 

Task failures do not affect/slow down the queue; an event ('task error')
is emitted from the actionQueue instance (see below). It is also thrown
from the process function's promise result.

It's the user's responsibility to ensure that the completion of the function
truly reflects the end of all activity generated by that function. 

## Task Output and exception 

On completion of the `.add` promise, the entire task is returned; 
any output of the function is saved in the tasks' `.output` parameter.

On an exception, the Promise fails with an object containing two properties, 
err and task; the former is whatever error was thrown, and the task property
is the container for the function, input args, and also should contain the same
thrown error. 

Also, failed tasks are emitted from the `failed` subject attached to the 
queue. 

## Parameters

Any arguments to process are saved and passed through to the first argument
(which must be a function). 

**THE FIRST ARGUMENT TO THE FUNCTION WILL BE THE TASK RECORD ITSELF!!!**

this is to express the stopFlag to the function to enable interruption 
when possible. 

```javascript

myDatabaseQueue.add(saveToDatabase, {name: 'Bob', age: 10});
myDatabaseQueue.add(saveToDatabase, {name: 'Rob', age: 10});

```

## Order of Execution, and guarantees

the functions will be *attempted* in the order they are received;
i.e., first in, first out. Of course, there is no guarantee on when
any given function completes. (or if it completes). 

The single parameter to the creation of an AsyncQueue instance, 
`maxConcurrency`, guarantees that a task will not transfer from 
delayed to active while there are that many active tasks. 

# Advanced/Internal details

The details below are not required to use this module; however
if you want to invest more effort in monitoring the queue or diagnosing
performance of badly performing tasks you might find it useful 

## Monitoring activity

The actionQueue is an EventEmitter instance. Events emitted include: 

* 'active' - number (count of currently active tasks)
* 'delayed' - number (count of pending tasks)
* 'finished' - task
* 'failed' - task

## Suspending Tasks

Attempting to suspend a task is only likely to succeed if other tasks
have overloaded the queue and forced a task to be delayed. That said:
there is a `.suspend(task)` method which will attempt to remove the 
task from execution; it will return one of many outputs:

* if it successfully removes the task before it is attempted it returns true.
* If the task is active, it returns the string 'active'.
* If the task is finished, it returns the string 'finished'.
* If the task was already suspended it returns null. 
* If the task is not found -- or if it finished or failed -- it returns false.

Note - every time a task is added to the queue, the `._lastTask` property
retains the task created to track the execution of your requested function.

alternately in place of `.add` you can call `.task(fn, ...args)`; this 
method returns the Task instance.

## `finished` and `failed` Subjects

Unlike `active` and `delayed` queues which keep Sets of tasks, finished and
failed simply broadcast and forget individual tasks. 

## Task

Task is a Rxjs Subject with a few extra properties and methods:

### Constructor

new Task(fn: function, args: any[])

### Properties:

* $fn {function}
* $args: {any[]}
* $output: any -- the output of the function when performed. 
* thrownError: if the function fails, this is where the error will be saved to

### Methods:

In addition to all the signature methods of Rxjs [Subjects](https://rxjs.dev/api/index/class/Subject)
* $perform() -- executes the function (async) with arguments `(task, ...task.$args) and
  preserves the result into $output. 
* complete() -- suspends the task, preventing $perform from being executed,
  unless of course it has already begun or been completed. 
* subscribe(onComplete) or 
* subscribe({next(output), complete(), error()}) listen for the execution
  of the task. 